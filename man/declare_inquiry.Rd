% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/declare_estimand.R
\name{declare_inquiry}
\alias{declare_inquiry}
\alias{declare_inquiries}
\alias{declare_estimand}
\alias{declare_estimands}
\alias{inquiry_handler}
\title{Declare inquiry}
\usage{
declare_inquiry(..., handler = inquiry_handler, label = "inquiry")

declare_inquiries(..., handler = inquiry_handler, label = "inquiry")

declare_estimand(...)

declare_estimands(...)

inquiry_handler(data, ..., subset = NULL, term = FALSE, label)
}
\arguments{
\item{...}{arguments to be captured, and later passed to the handler}

\item{handler}{a tidy-in, tidy-out function}

\item{label}{a string describing the step}

\item{data}{a data.frame}

\item{subset}{a subset expression}

\item{term}{TRUE/FALSE}
}
\value{
a function, I(), that accepts a data.frame as an argument and returns a data.frame containing the value of the inquiry,  a^m.
}
\description{
Declares inquiries, or the inferential target of interest. Conceptually very close to "estimand" or "quantity of interest".
}
\details{
For the default diagnosands, the return value of the handler should have \code{inquiry_label} and \code{inquiry_value} columns.

If term is TRUE, the names of ... will be returned in a \code{term} column,
and \code{inquiry_label} will contain the step label. This can be used as
an additional dimension for use in diagnosis.
}
\examples{

# Set up a design stub for use in examples:

design_stub  <- 
  declare_model(
    N = 100, 
    X = rnorm(N),
    potential_outcomes(Y ~ Z + rnorm(N))
  ) + 
  declare_assignment(Z = complete_ra(N, m = 50)) + 
  declare_measurement(Y = reveal_outcomes(Y ~ Z))

# sGet example data to compute inquiries on
dat <- draw_data(design_stub)

# ----------
# 1. Single inquiry
# ----------

# Declare an average treatment effect (ATE) inquiry

my_inquiry_ATE <- declare_inquiry(ATE = mean(Y_Z_1 - Y_Z_0))
my_inquiry_ATE(dat)

# or a conditional inquiry

my_inquiry_ATT <- declare_inquiry(ATT = mean(Y_Z_1 - Y_Z_0),
                                  subset = (Z == 1))
my_inquiry_ATT(dat)

# Add inquiries to a design along with answer strategies 
# (estimators) that reference them

my_estimator <- declare_estimator(Y ~ Z, inquiry = "ATE")

design_one <- design_stub + my_inquiry_ATE + my_estimator

draw_inquiries(design_one)

# ----------
# 2. Multiple inquiries
# ----------

# You can also specify multiple inquiries for a single estimator 

my_estimator_two <- declare_estimator(Y ~ Z, 
inquiry = c("ATE", "ATT"))

design_two <- design_stub + my_inquiry_ATE + 
  my_inquiry_ATT + my_estimator_two

draw_inquiries(design_two)

# ----------
# 3. Paired inquiries / estimators from a single model
# ----------

# For convenience you can also declare multiple inquiries
# simultaneously and connect these to the corresponding 
# terms in the estimator. 

# Name your inquiries the term name they get in your
# estimator, and set `term = TRUE`

inquiries_regression <- declare_inquiries(
  `(Intercept)` = mean(Y_Z_0),
  `Z` = mean(Y_Z_1 - Y_Z_0),
  term = TRUE,
  label="Regression_inquiries"
)

# For the model based estimator, specify the inquiry as usual,
# but also set `term = TRUE`
estimators_regression <- declare_estimator(
  Y ~ Z,
  inquiry = inquiries_regression,
  model = lm,
  term = TRUE
)

design_regression <- design_stub + inquiries_regression +
  estimators_regression

run_design(design_regression)

# ----------
# 4. Custom inquiry function
# ----------

# You can declare more complex inquiries by defining custom
# inquiry functions:

inquiry_function <- function(data, label) {
  ret <- with(data, median(Y_Z_1 - Y_Z_0))
  data.frame(inquiry_label = label,
             inquiry_value = ret,
             stringsAsFactors = FALSE)
}

inquiry_custom <- declare_inquiry(handler = inquiry_function,
  label = "medianTE")

inquiry_custom(dat)

# Use with custom estimators
estimator_function <- function(data){
  data.frame(estimate = with(data, median(Y)))
}
estimator_custom <-
  declare_estimator(handler = tidy_estimator(estimator_function),
                    inquiry = inquiry_custom)

design_custom <- design_stub + inquiry_custom +
  estimator_custom

run_design(design_custom)

# ----------
# 5. Batch inquiries and estimators
# ----------

# You can declare a group of inquiries with distinct labels
# in one go and link them manually to a group of estimators.
# In this case you can add a \code{term} argument to the 
# custom estimators to identify them.

f1 <- function(data) {
  data.frame(inquiry_label = c("control", "ate"),
             inquiry_value = with(data, c(mean(Y_Z_0), mean(Y_Z_1 - Y_Z_0))),
             stringsAsFactors = FALSE)
}
inquiries <- declare_inquiry(handler = f1)

f2 <- function(data) {
  data.frame(estimate = 
               with(data, c(mean(Y[Z == 0]),
                            mean(Y[Z == 1]) - mean(Y[Z == 0]))),
             term = 1:2)
}

estimators <- declare_estimator(handler = label_estimator(f2), 
                            inquiry = c("control", "ate"), label = "custom")
                            
design   <- design_stub + inquiries + estimators

\dontrun{
diagnose_design(design, sims = 20, bootstrap_sims = FALSE,
                diagnosands = declare_diagnosands(
                select = c(mean_estimate, mean_inquiry_value)))
}
}
